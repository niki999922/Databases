1.1) FreeSeats(FlightId) — список мест, доступных для продажи и доступных для бронирования.

start transaction isolation level read committed

Рассмотрим 4 вида аномалии:
1) Косая запись (далее КЗ) - данный запрос только на чтение, поэтому в этом проблем нет.
2) Фантомная запись (далее ФЗ) - так как читаем 1 раз, нет проблем.
3) Неповторяемое чтение (далее НЧ) - так как читаем 1 раз, нет проблем.
4) Грязное чтение (далее ГЧ) - у нас может возникнуть ситуация, что человек начал покупать место в другой транзакции, но она была отменена, а мы прочитали данные, которые считаются, как то что это место куплено, что не так. Поэтому тут у нас проблемы и берём read committed.
Также для всех последующих пунктов будем считать, что у меня кроме Flights(FlightId, FligtTime, PlaneId), Seats(PlaneId, SeatNo) есть таблица SeatStatus (userId, seatNo, flightId, status, time), где status принимает {'RESERVED', 'BOUGHT'}, а time - timestamp. А также Users(UserId, UserPassword).






1.2) Reserve(UserId, Pass, FlightId, SeatNo) — пытается забронировать место. Возвращает истину, если удалось и ложь — в противном случае.

start transaction isolation level repeatable read 

Либо мы обновляем уже существующее место в SeatStatus. Для этого достаточно взять блокировку только на эту запись. Для этого лучше всего подходит repeatable read. У нас нет проблемы косой записи, так как меняем одну запись. Нет фантомной записи, так как работаем с записью. Но есть "проблема неповторяемого" чтение, так как другая транзакция могла выполняться для двух разных пользователей и обоим вернётся правда, но запишется только один (когда истёк срок резерва).
Либо мы добавляем новую запись в SeatStatus, что также подходит для repeatable read. Но мы ограничены "неповторяемым чтение" из абзаца выше, поэтому дальше рассматриваться более мягкие ограничения нет смысла.






1.3) ExtendReservation(UserId, Pass, FlightId, SeatNo) — пытается продлить бронь места. Возвращает истину, если удалось и ложь — в противном случае.

start transaction isolation level read committed

Мы обновляем уже существующее место в SeatStatus. Для этого надо взять блокировку только на эту запись. У нас нет проблемы косой записи, так как меняем одну запись.  Нет фантомной записи, так как работаем с записью. Нет проблемы "неповторяемого чтение", так как другая транзакция могла завершиться и мы продлим просто резервацию в конце нашей транзакции, система останется в корректном состоянии. Для этого лучше всего подходит repeatable committed.







1.4) BuyFree(FlightId, SeatNo) — пытается купить свободное место. Возвращает истину, если удалось и ложь — в противном случае.

start transaction isolation level repeatable read

Либо мы обновляем уже существующее статус места в SeatStatus. Для этого достаточно взять блокировку только на эту запись. Для этого лучше всего подходит repeatable read. У нас нет проблемы косой записи, так как меняем одну запись. Нет фантомной записи, так как работаем с записью. Но есть "проблема неповторяемого" чтение, так как другая транзакция могла выполняться для двух разных пользователей и обоим вернётся правда, но запишется только один (когда истёк срок резерва).
Либо мы добавляем новую запись в SeatStatus, что также подходит для repeatable read. Но мы ограничены "неповторяемым чтение" из абзаца выше, поэтому дальше рассматриваться более мягкие ограничения нет смысла.






1.5) BuyReserved(UserId, Pass, FlightId, SeatNo) — пытается выкупить забронированное место (пользователи должны совпадать). Возвращает истину, если удалось и ложь — в противном случае.

start transaction isolation level read committed

Такая же ситуация, как с BuyFree, только тут мы знаем что у нас 1 пользователь и не будет 2 параллельных update от разных пользователей. Но мы не можем взять read uncommitted так как у не факт, что проверка пользователя прошла успешно. Поэтому берём read committed.






1.6) FlightsStatistics(UserId, Pass) — статистика по рейсам: возможность бронирования и покупки, число свободных, забронированных и проданных мест.

start transaction isolation level read committed

Запрос только на чтение, но требует авторизацию, поэтому будем использовать read committed.






1.7) FlightStat(UserId, Pass, FlightId) — статистика по рейсу: возможность бронирования и покупки, число свободных, забронированных и проданных мест.

start transaction isolation level read committed

Запрос только на чтение, но требует валидацию пользователя, поэтому будем использовать read committed.




1.8) CompressSeats(FlightId) — оптимизирует занятость мест в самолете. В результате оптимизации, в начале самолета должны быть купленные места, затем — забронированные, а в конце — свободные. Примечание: клиенты, которые уже выкупили билеты так же должны быть пересажены.

start transaction isolation level snapshot

Так как необходимо оптимизировать таблицу, то на время нужно запретить покупку. Проблем с косой записью возникнуть не должно, поэтому snapshot.




2.0) Общий план *

У нас будет поднят веб сервис, который будет сам общаться с базой данных. Для пользователя будет удобный и понятный UI/UX.
Для первого этапа мне нужно будет получить индификатор полёта. Его может выбрать из представленных списка, который берётся по таблице всех полётов.
Потом у пользователя будет кнопка, после нажатия будет перерисована страничка со списком свободных мест. Будет запрос на FreeSeats. Запросы выполнены в postgreSQL 12.4.


2.1) Запрос списка свободных мест *. Приведите соответствующие SQL-запросы


create transaction isolation level read committed;
select freeSeats(:flightId);
commit;



2.2) Взаимодействие с пользователем *. Укажите как будет релизовано взаимодействие с пользователем

Так как мы хотим, чтобы покупки были по привязанным пользователям, то для дальнейших шагов надо будет пройти форму авторизации. Потом будет удобный UI, где можно будет зарезервировать место для полёта с нужным id. Также можно будет его купить по специальному попапу по полёту (разница по BuyFree и BuyReserverd немного скрыта от пользователя). Он лишь увидит маркет и описания места, что берёт. А какой запрос выполнить знает уже Backend. После действия сообщим об успешном или не успешном совершении операции.


2.3) Действия с местом *. Приведите соответствующие SQL-запросы


create transaction isolation level repeatable read;
select Reserve(:userId, :pass, :flightId, :seatNo);
commit;

create transaction isolation level repeatable read;
select BuyFree(:flightId, :seatNo);
commit;

create transaction isolation level read committed;
select BuyReserved(:userId, :pass, :flightId, :seatNo);
commit;


