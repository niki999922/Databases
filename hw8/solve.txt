1.1

1.
1) (StudentId) - объявим его как unique index и используем индексирование с помощью hash. Так как StudentId является primary key, то делаем по нему индекс. У нас также будут быстро выполняться запросы на наличие записи в таблице по ключу.
2) (StudentName, StudentId, GroupId) - объявим его как покрывающий index и используем индексирование с помощью btree. Получим таким образом отсортированные записи. Сможем получать записи по префиксу фамилии, а потом имени (так как поле StudentName содержит ФИО). Добавить StudentId и GroupId не дорого, так как это просто целочисленный тип данных под id и много места не ест, а при запросах нам не надо будет ходить в память за чтением этих полей. GroupId не всегда нужен, поэтому идёт в конце, а значение в индексе мы считаем по полям слева на право (иначе бы нам пришлось для StudentId каждый раз проходить по GroupID).
3) (GroupId, StudentId) - объявим его как покрывающий index и используем индексирование с помощью btree. Такой индекс понадобиться при join таблиц, он будет отсортирован сначала по GroupId, а потом по StudentId. Таким образом при двойне таблицы студентов и таблицы с группами у нас будут обращения сначала только к одной группе, потом только к другой и до конца и никогда не повторяться, что позволит закешировать запись по группе. Поесть первые n студентов в группе с индексом "1" и не надо каждый раз из памяти эту запись таскать, у этих n студентов будет такая группа, поэтому просто брать из кэша эту запись.

2.
1) (GroupId) - объявим его как unique index и используем индексирование с помощью hash. Так как GroupId является primary key, то делаем по нему индекс. У нас также будут быстро выполняться запросы на наличие записи в таблице по ключу.
2) (GroupName, GroupId) - объявим его как покрывающий index и используем индексирование с помощью btree. Будем иметь отсортированные записи по GroupName и потом по GroupId. Добавить GroupId недорого, так как целочисленный тип и много не занимает. При запросах нам не надо будет ходить дополнительно в память за чтением GroupId. Сможем получать записи по префиксу имени группы.

3.
1) (CourseId) - объявим его как unique index и используем индексирование с помощью hash. Так как CourseId является primary key, то делаем по нему индекс. У нас также будут быстро выполняться запросы на наличие записи в таблице по ключу.
2) (CourseName, CourseId) - объявим его как покрывающий index и используем индексирование с помощью btree. Будем иметь отсортированные записи по CourseName и потом по CourseId. Добавить CourseId недорого, так как целочисленный тип и много не занимает. При запросах нам не надо будет ходить дополнительно в память за чтением CourseId. Сможем получать записи по префиксу имени предмета.

4.
1) (LecturerId) - объявим его как unique index и используем индексирование с помощью hash. Так как LecturerId является primary key, то делаем по нему индекс. У нас также будут быстро выполняться запросы на наличие записи в таблице по ключу.
2) (LecturerName, LecturerId) - объявим его как покрывающий index и используем индексирование с помощью btree. Будем иметь отсортированные записи по LecturerName и потом по LecturerId. Добавить LecturerId недорого, так как целочисленный тип и много не занимает. При запросах нам не надо будет ходить дополнительно в память за чтением LecturerId. Сможем получать записи по префиксу имени лектора (ФИО).

5.
1) (GroupId, CourseId) - объявим его как unique index и используем индексирование с помощью hash. Так как (GroupId, CourseId) является primary key, то делаем по нему индекс. У нас также будут быстро выполняться запросы на наличие записи в таблице по ключу.
2) (LecturerId, CourseId, GroupId) - объявим его как покрывающий index и используем индексирование с помощью btree. Добавить GroupId недорого, так как целочисленный тип данных + не придётся лишний раз ходить в память за записью при запросах. Также GroupId в конце так как в записях нам могут они понадобиться, но не всегда. А иначе бы приходилось всегда ходить до CourseId через GroupId, что лишнее. Будем иметь отсортированный по id преподавателя записи, что позволит нам быстрее оставлять те записи, что соответствуют определённому ключу и с ними как-то работать.

6.
1) (StudentId, CourseId) - объявим его как unique index и используем индексирование с помощью hash. Так как (StudentId, CourseId) является primary key, то делаем по нему индекс. У нас также будут быстро выполняться запросы на наличие записи в таблице по ключу.
2) (Mark, CourseId, StudentId) - объявим его как покрывающий index и используем индексирование с помощью btree. Добавить StudentId недорого, так как целочисленный тип данных + не придётся лишний раз ходить в память за записью при запросах. Сделаем StudentId в конце, чтобы каждый раз через него не ходить, ибо он не во всех запросах нужен, но может сэкономить в некоторых время. Будем иметь отсортированные по оценкам, а потом и по предмету записи, для удобного поиска по определённым условия (не придётся всю таблицу обходить) + не надо лишнее из памяти читать. 

1.2

1.
1) create unique index using hash on Students (StudentId);
2) create index using btree on Students (StudentName, StudentId, GroupId);
3) create index using btree on Students (GroupId, StudentId);

2.
1) create unique index using hash on Groups (GroupId);
2) create index using btree on Groups (GroupName, GroupId);

3.
1) create unique index using hash on Courses (CourseId);
2) create index using btree on Courses (CourseName, CourseId);

4.
1) create unique index using hash on Lecturers (LecturerId);
2) create index using btree on Lecturers (LecturerName, LecturerId);

5.
1) create unique index using hash on Plan (GroupId, CourseId);
2) create index using btree on Plan (LecturerId, CourseId, GroupId);

6.
1) create unique index using hash on Marks (StudentId, CourseId);
2) create index using btree on Marks (Mark, CourseId, StudentId);


2.1

1) Предметы у преподователя - узнать, что ведёт данный человек
2) Число  разных преподавателей по предмету - актуально, когда хочешь ходить к другому преподавателю и смотришь какие есть (хочешь знать насколько широк выбор)
3) Студенты с фимилией начинающий с префикса - поисковые системы людей, как в ИСУ

2.2

1) Уже есть необходимый индекс - это btree Plan (LecturerId, CourseId, GroupId). Просто оставить записи с определённым LecturerId. Так как в дереве, то поиск по префиксу работает быстро.
2) Добавить индекс - btree Plan (CourseId, LecturerId). Тогда сможем быстро получать по заданному предмету всех преподователей, которые к нему относятся. А посчитать сколько их не сложно.
3) Уже есть такой индекс - это btree Students (StudentName, StudentId, GroupId). Так как дерево, есть поиск по префиксу.

2.3

create index using btree on Plan (CourseId, LecturerId);



3.1

Я бы добавил индекс btree Marks (CourseId, StudentId, Mark), так как позволит получить записи по префиксу, так как это дерево (быстро). И так как мы уже имеем индекс btree Students (GroupId, StudentId), можно получить быстро записи по группе. И так как они оба отсортированные будут, ибо дерево, то будет проще делать join, и не ходить в разные записи, они упорядочены => можно будет закэшировать некоторую информацию и это будет быстрее. Данный индекс (CourseId, StudentId, Mark) надо смотреть на практике, так как оценки часто меняются, а запросы могут быть не часто и возможно проще делать по обычному.

3.2

create index using btree on Marks (CourseId, StudentId, Mark);